32道题

**<font style="color:#58a401;">先序遍历：</font>**

**<u><font style="color:#078654;background-color:#fbf5b3;">求数字</font></u>**<u><font style="color:#0e52d4;">(最大高度,最小深度,结点个数</font></u><u><font style="color:#078654;">)。</font></u>

**<u><font style="color:#078654;background-color:#fbf5b3;">镜像判断</font></u>**<u><font style="color:#078654;">（</font></u><u><font style="color:#0e52d4;">判断对称二叉树，判断是否相同的树）。</font></u>

**<u><font style="color:#078654;background-color:#fbf5b3;">遍历时调用函数</font></u>****<u><font style="color:#078654;">（</font></u>**<u><font style="color:#0e52d4;">最大路径和,直径,树的子结构,判断平衡二叉树)。</font></u>

**<u><font style="color:#0080a0;background-color:#fbf5b3;">带状态的DFS</font></u>****<u><font style="color:#0080a0;">（</font></u>**<u><font style="color:#0e52d4;">左叶子之和，根节点到叶子节点数字之和，所有路径，路径总和，最大二叉树,</font></u>[二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)<u><font style="color:#0e52d4;">)。</font></u>

**<u><font style="color:#0080a0;background-color:#fbf5b3;">二叉搜索树(</font></u>**<u><font style="color:#0e52d4;">判断/修建/插入/搜索/删除二叉搜索树，二叉树剪枝)。</font></u>

**<font style="color:#58a401;background-color:#fbf5b3;">层序遍历(</font>**<u>之子打印、判断完全二叉树、最大层内元素、左下角值、最大宽度）</u>

**<font style="background-color:#fbf5b3;">中序遍历(</font>**<u>BST第k大，BST转循环链表，BST转累加树)</u>

<font style="background-color:#fbf5b3;">后序遍历</font><u><font style="background-color:#fbf5b3;">(</font></u><u>最近公共祖先，二叉树展为链表，翻转二叉树)</u>

<h4 id="68f1a0ca">二叉树定义</h4>
```plain
struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode() : val(0), left(nullptr), right(nullptr) {}
      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right){}
};
```

<h4 id="86ea597c">后序遍历</h4>
```plain
if(root==nullptr)return;
dfs(root->left);
dfs(root->right);
res.push_back(root->val);
```

<h4 id="5ca1aa17">中序遍历</h4>
```plain
if(root==nullptr)return;
dfs(root->left);
res.push_back(root->val);
dfs(root->right);
```

<h4 id="40c68aa5">先序遍历</h4>
```plain
if(root==nullptr)return;
res.push_back(root->val);
dfs(root->left);
dfs(root->right);
```

<h4 id="e19441db">层级遍历</h4>
图的广度优先遍历是树的层次遍历的拓展

按照数的高度从上到下，从左到右一次遍历节点

在遍历时需要用到队列

例：A-BC-DFG

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810229727-42d8b6cb-265c-448e-b7c4-7a8ec9258750.png)

**伪代码**：

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810229672-4b38cc70-7b60-403e-bf46-de10e89cb6ce.png)

```plain
if(root==null)return;
q;
q.add(root);
while(q不空){
   int size=q.size();
   for(int i=0;i<size;i++){
        q.pop();
        if(q.left)q.add(q.left);
        if(q.right)q.add(q.right);
}
```

<h4 id="b2d14110">先序遍历相关</h4>
**<u><font style="color:#58a401;">求数字（最大高度，最小深度，二叉树结点个数）</font></u>**

<h5 id="41021180"><font style="color:#0e52d4;">求数字</font></h5>
<h6 id="add5176a">**最大高度（高度）**</h6>
求树的最大高度

```plain
D(root):
  root==null return 0
  return max(D(left),D(right))+1
```

<h6 id="59dfa1d5">**最小深度**</h6>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

需要讨论三种特殊情况注意

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810229692-bc35b356-d66f-436c-b821-7cc739500e41.png)

答案为5。

如果直接返回min(D(left),D(right))+1.当left为空的时候，D(left)为0，min值为0，但是右面不空的话一定大于0，不符合题意。

```plain
D(root):
  root空 return 0
  左空右不空 return D(right)+1
  右空左不空 return D(left)+1
  return min(D(left),D(right))+1
```

<h6 id="83851eb5">**求二叉树结点个数**</h6>
**（leetcode 222）**

[. - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

```plain
countNodes(TreeNode* root):
       if(!root)return 0;
       return 1+countNodes(root->left)+countNodes(root->right);
```

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810229684-34cb185f-628c-414a-8bcf-6de29158ffd5.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810229698-3b79be95-daa5-4827-9ff9-9f5d3021cc0c.png)

```plain
f(root); 
dfs(l);
dfs(r);
```

<h6 id="WqN7N">[1339. 分裂二叉树的最大乘积](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/)</h6>
给你一棵二叉树，根为 `root`。请删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。由于答案可能会很大，请将结果对 10^9 + 7 取模后再返回。

If we know the sum of a subtree，the answer is max( (total_sum - subtree_sum) * subtree_sum) in each node。

求和的时候更新max值即可。需要使用long long 防止溢出，并且最后在取模。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230169-48434e66-775f-472a-9d9c-990ae8c4f0fb.png)

```plain
typedef long long LL;
class Solution {
public:
    LL calRootSum(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        return root->val + calRootSum(root->left) + calRootSum(root->right);
    }
LL subTreeSum(TreeNode* root, LL rootSum, LL& ret) {
    if (root == NULL)return 0;
    LL subSum=root->val+subTreeSum(root->left, rootSum,ret)+subTreeSum(root->right, rootSum, ret);
    ret = max(ret, (rootSum - subSum) * subSum);
    return subSum;
}
    int maxProduct(TreeNode* root) {
        LL rootSum = calRootSum(root);
        LL ret = 0;
        subTreeSum(root, rootSum, ret);
        return ret % LL(1e9 + 7);
    }
};
```

<h5 id="cb88da46"><font style="color:#0e52d4;">镜像判断</font></h5>
<h6 id="9eabc688">**判断对称二叉树**</h6>
```plain
//判断两棵树是否对称  
bool isSymmetric(TreeNode* l, TreeNode* r)
    //如果两个节点都为空，则是对称的
    if (l 空&& r空)return true;  
    //如果只有一个节点为空，或者两个节点都不为空但值不相等，则不是对称的  
    if (l == nullptr || r == nullptr || l->val != r->val)return false;  
    //递归判断左子树和右子树是否对称  
    return isSymmetric(l->left, r->right) && isSymmetric(l->right, r->left);  
    //判断一棵二叉树是否是对称二叉树
bool isSymmetric(TreeNode* root) {  
    //空树是对称的  
    if (root == nullptr) return true;  
    //对于非空树，只需要判断根节点的左右子树是否对称  
    return isSymmetric(root->left, root->right);  
}
```

时间复杂度是 O(n)，因为需要遍历二叉树的每个节点一次。在递归过程中，对每个节点的左子树和右子树进行对称性的比较。对于每个节点，进行常数时间的值比较，并递归地检查其子节点。由于每个节点只会被访问一次，时间复杂度是线性的。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230199-7d3c3152-b1db-483b-bd57-03f8fe1ba067.png)

<h6 id="88759bdf">**判断是否是相同的树**</h6>
```plain
// 判断两个树是否相同  
isSame(p, q):  
        if(!p&&!q)return true;
        if(!p||!q)return false;
        return p->val==q->val&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
```

时间复杂度O(n)

<h6 id="-1">[951. 翻转等价二叉树](https://leetcode.cn/problems/flip-equivalent-binary-trees/)</h6>
我们可以为二叉树 **T** 定义一个 **翻转操作,**如下所示:选择任意节点，然后交换它的左子树和右子树。只要经过一定次数的翻转操作后，能使 **X** 等于 **Y**，我们就称二叉树 **X**_翻转 等价 _于二叉树 **Y**。这些树由根节点 `root1` 和 `root2` 给出。如果两个二叉树是否是_翻转 等价 _的函数，则返回 `true` ，否则返回 `false`.

每棵树中的每个值都是唯一的、在 `[0, 99]` 范围内的整数。

每个值是唯一的，所以如果不相等就必须要翻转判断。

思路和上面两题类似。

```plain
class Solution {
public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if(!root1&&!root2)return true;
        if(!root1||!root2)return false;
        if(root1->val!=root2->val)return false;
        return 
        (flipEquiv(root1->left,root2->right)&&flipEquiv(root1->right,root2->left))
        ||(flipEquiv(root1->left,root2->left)&&flipEquiv(root1->right,root2->right));
    }
};
```

1. **基本情况判断**：
    - **两棵树都为空**：`root1` 和 `root2` 都为空指针，说明两棵空树是翻转等价的，直接返回 `true`。
    - **只有一棵树为空：**`root1` 和 `root2` 中只有一棵树为空，而另一棵不为空，那么这两棵树不可能通过翻转操作变得相同，所以返回 `false`。
    - **根节点值不相等**：如果 `root1` 和 `root2` 的根节点的值不相等，无论如何进行翻转操作，这两棵树都无法变得相同，因此返回 `false`。
2. **递归判断子树：交换或者不交换都判断一下，然后用||判断条件。**
    - **情况一：交换左右子树**：检查能否通过交换 `root1` 的左右子树，使得它与 `root2` 等价。具体做法是递归调用 `flipEquiv` 函数，判断 `root1` 的左子树与 `root2` 的右子树是否等价，同时判断 `root1` 的右子树与 `root2` 的左子树是否等价。如果这两个递归调用的结果都为 `true`，则说明通过交换 `root1` 的左右子树可以使其与 `root2` 等价。
    - **情况二：不交换左右子树**：检查不交换 `root1` 的左右子树时，它是否与 `root2` 等价。即递归调用 `flipEquiv` 函数，判断 `root1` 的左子树与 `root2` 的左子树是否等价，同时判断 `root1` 的右子树与 `root2` 的右子树是否等价。如果这两个递归调用的结果都为 `true`，则说明不交换 `root1` 的左右子树时，它与 `root2` 等价。

<h6 id="097fa4d0">**合并二叉树**</h6>
两个二叉树对应位置相加，如果有一个为空视为0，返回新的二叉树

```plain
function mergeTrees(root1, root2):  
    // 创建一个新的根节点，初始值为0  
    root = new TreeNode(0)  
    // 如果两个根节点都为空，则返回空  
    if root1 is null and root2 is null:  
        return null
    // 如果root1为空，返回root2  
    if root1 is null:
        return root2  
    // 如果root2为空，返回root1  
    if root2 is null:  
        return root1  
    // 合并两个根节点的值  
    root.val = root1.val + root2.val  
    // 递归地合并左子树和右子树  
    root.left = mergeTrees(root1.left, root2.left)  
    root.right = mergeTrees(root1.right, root2.right) 
    // 返回合并后的新树的根节点  
    return root
```

<h5 id="6e36612c"><font style="color:#0e52d4;">遍历时调用函数</font></h5>
<h6 id="1c39e0eb">**二叉树的最大路径和(*)**</h6>
路径为一条从树中任意节点出发,达到任意节点的序列(不一定经过根节点)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230222-5094db87-9153-4f46-aa6b-f4cd138147c3.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230284-00cb8c1a-d762-4997-8445-d78a27a46648.png)

```plain
class Solution {
public:
    int res=INT_MIN;
    int s(TreeNode *node){
        if(!node)return 0;
        return node->val+max(s(node->left),max(s(node->right),0));
    }
  //s(node)计算以当前节点为终点的路径最大和
  void dfs(TreeNode *root){
        if(root==nullptr)return;
        int sum=root->val+max(s(root->left),0)+max(s(root->right),0);
        res=max(res,sum);
        dfs(root->left);
        dfs(root->right); 
   }
  int maxPathSum(TreeNode* root) {
        dfs(root);    
        return res;
    }
};
```

<h6 id="0604738e">**<font style="color:#0e52d4;">树的子结构</font>**</h6>
![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230325-8da8a872-1388-4809-aefc-8880ebff22bb.png)

[. - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/)

isSubTree(A,B)：//判断B是否是A的子结构

思路：A null 或 B null返回fasle。

先序遍历A,每个节点分别判断以B为根的树是否是该树的子树。

每个节点判断：bnull返回true。a null b不null返回fasle. （ab都不null）return a->val==b->val&&递归判断左右。

```plain
bool is(TreeNode *a,TreeNode *b){
      if(!b)return true;
      if(!a&&b)return false;
      return a->val==b->val&&is(a->left,b->left)&&is(a->right,b->right);
   }
    bool isSubStructure(TreeNode* a, TreeNode* b){
         if(a==nullptr||b==nullptr)return false;
  bool root=is(a,b)||is(a->left,b)||is(a->right,b); //为什么是不是写错了
  bool child=isSubStructure(a->left,b)||isSubStructure(a->right,b);
       return root||child;
   }
```

<h6 id="846691a1">**判断平衡二叉树**</h6>
```plain
//计算树的高度  
h(root):
    if root==nullptr:
        return 0  
    return 1+max(h(root.left),h(root.right))  
//判断平衡二叉树  
isB(root):
   if root==null:  
        return true  
   return abs(h(root.left) - h(root.right)) <= 1 && isB(root.left) && isB(root.right)
```

<h5 id="7a3b33f6">**<font style="color:#0e52d4;">带状态的DFS</font>**</h5>
<h6 id="e162a85f">**左叶子之和**</h6>
带标记信息的dfs：用flag标记当前节点是父节点的左节点还是右节点，1左2右

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230770-5163c57d-a47c-4bba-9e14-24f7c34b616a.png)

```plain
sum(root):
   return dfs(root,0)
dfs (root, flag):
   if(!root) return 0
   if(!root.left&&!root.right&&flag==1)return root.val
   return dfs(root.left,1)+dfs(root.right,2)
```

<h6 id="dc7d77c3">**求根节点到叶节点数字之和**</h6>
**LeetCode129 **

<!!!!>边界条件

输入：root = [1,2,3]。输出：25。从根到叶子节点路径 1->2 代表数字 12。从根到叶子节点路径 1->3 代表数字 13。数字总和 = 12 + 13 = 25。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230941-af48c15a-5239-4ba9-80f1-52444f051416.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230777-5df758f6-cfb4-470a-bb65-8b9979352294.png)

root,sum表示[已经]遍历root节点所有sum的值（不包括root)

可以看成走地图的问题

```plain
int dfs(TreeNode *root,int sum){
    if(!root)return 0;
    if(!root->left&&!root->right){
        return sum*10+root->val;//走到边界,统计结果
    }
    return dfs(root->left,sum*10+root->val)+dfs(root->right,sum*10+root->val);
}
int sumNumbers(TreeNode* root) {
    return dfs(root,0);
}
```

<h6 id="-2">[1315. 祖父节点值为偶数的节点和](https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/)</h6>
给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：该节点的祖父节点的值为偶数(一个节点的祖父节点是指该节点的父节点的父节点）如果不存在祖父节点值为偶数的节点，那么返回`0`。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230834-43e0ed96-d521-4d85-b440-d1d55c857c12.png)

遍历的时候使用两个参数，记录parent和grandparent。记录parent是为了更新的时候，使用parent更新grandparent。

```plain
class Solution {
public:
    int res;
    void dfs(TreeNode *root,TreeNode *parent,TreeNode *grand){
        if(!root)return;
        if(grand&&grand->val%2==0)res+=root->val;
        dfs(root->left,root,parent);
        dfs(root->right,root,parent);
    }
    int sumEvenGrandparent(TreeNode* root) {
        dfs(root,nullptr,nullptr);
        return res;
    }
};
```

<h6 id="-3">[508. 出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)</h6>
给你一个二叉树的根结点`root`,请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和(不限顺序)。一个结点的**<font style="color:#078654;">「子树元素和」</font>**定义为以该结点为根的二叉树上所有结点的元素之和(包括结点本身)。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810230839-1ebff5d3-8ad7-4ab9-8513-5675d556f8c7.png)

在遍历的时候统计数据（和最长交错路径类似）

```plain
class Solution {
public:
    // 使用unordered_map来存储子树和及其频率
    unordered_map<int, int> sumFreq;
    int dfs(TreeNode* root) {
        if (!root) return 0;
        int sum = root->val+dfs(root->left)+dfs(root->right);
        sumFreq[sum]++; //统计子树和的频率
        return sum;
    }
    vector<int> findFrequentTreeSum(TreeNode* root) {
        if (!root) return {};
        dfs(root); // 计算所有子树和及其频率
        // 找到最大频率
        int maxFreq = 0;
        for (const auto& pair : sumFreq) {
            if (pair.second > maxFreq) {
                maxFreq = pair.second;
            }
        }
        // 收集所有频率等于最大频率的子树和
        vector<int> result;
        for (const auto& pair : sumFreq) {
            if (pair.second == maxFreq) {
                result.push_back(pair.first);
            }
        }
        return result;
    }
};
```

<h6 id="-4">[606. 根据二叉树创建字符串](https://leetcode.cn/problems/construct-string-from-binary-tree/)</h6>
![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231279-719b6a93-b204-44be-8b89-c415d6ab7619.png)

```plain
class Solution {
public:
    string tree2str(TreeNode* root) {
        if (!root) return "";
        // 转换当前节点值为字符串
        std::string s = std::to_string(root->val);
        // 如果存在左子树，则递归转换，并将其括起来
        if (root->left) {
            s += "(" + tree2str(root->left) + ")";
            // 仅当左子树存在但右子树不存在时，才需要特别处理右子树为空的情况
            if (root->right) {
                s += "(" + tree2str(root->right) + ")";
            }
        } else if (root->right) { // 如果只有右子树存在
            s += "()(" + tree2str(root->right) + ")";
        }
        return s;
    }
};
```

注意顺序，如果写错会有多余的括号。

<h6 id="-5">[988. 从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/)</h6>
给定一颗根结点为 `root` 的二叉树，树中的每一个结点都有一个 `[0, 25]` 范围内的值，分别代表字母 `'a'` 到 `'z'`。返回_**按字典序最小**__的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。_

注**：**字符串中任何较短的前缀在 **字典序上** 都是 **较小** 的：  
例如，在字典序上 `"ab"` 比 `"aba"` 要小。叶结点是指没有子结点的结点。 

节点的叶节点是没有子节点的节点。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231330-5dc420b2-90f4-4a93-9785-23b1743e7b6e.png)

走路径走到叶子节点后反转path，然后更新最小值。

```plain
class Solution {
public:
    string path;
    string res="zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz";
    void dfs(TreeNode *root){
        if(!root)return;
        if(!root->left&&!root->right){
            path+='a'+root->val;
            reverse(path.begin(),path.end());
            res=min(res,path);
            reverse(path.begin(),path.end());
            path.pop_back();
        }
        path+='a'+root->val;
        dfs(root->left); dfs(root->right);
        path.pop_back();
    }
    string smallestFromLeaf(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

<h6 id="-6">[1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)</h6>
给定二叉树的根节点 `root`，找出存在于 **不同** 节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。

（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）

<h6 id="480adf87">**二叉树的所有路径**</h6>
**LeetCode 257**

[. - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231398-d4611dcf-c26a-4da0-bc2e-1b429d3fe863.png)

思路：和dfs迷宫路径、排列问题相同。

<u>需要回溯。</u>

dfs(root)表示下一个要走的节点是root，状态就是root的值。走到节点把节点值转换成相应的字符串加入path，如果走到终点(叶子节点)，把path保存到二维数组。

<font style="background-color:#fbf5b3;">叶子节点的回溯要和其他节点保持一致，否则会出现问题。</font>

```plain
string path="";
  vector<string>res;
  void dfs(TreeNode *root){
      if(!root)return;
      if(!root->left&&!root->right){
         string tmp=path;
         path+=to_string(root->val);
         res.push_back(path);
         path=tmp;
         return;
      }
      string tmp=path;
      path+=to_string(root->val)+"->";
      dfs(root->left);
      dfs(root->right);
      path=tmp;
   }
    vector<string> binaryTreePaths(TreeNode* root) {
        dfs(root);
        return res;
 }
```

<h6 id="24aa87a9">路径总和</h6>
LeetCode113 

使用全局变量（target）进行传参。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231449-f0909150-6dd7-47c2-a2cc-fb83f51b9da4.png)

(1) if(sum>target)不能作为剪枝的条件，因为数可能是负数，所以会越加越小。

(2) 不能使用root为空作为递归的出口，因为叶子节点会走两次到空节点，结果会重复。

```plain
class Solution {
public:
    vector<vector<int>>res;
    vector<int>path;
    int target;
    void dfs(TreeNode *root,int sum){
        if(!root)return;
        if(!root->left&&!root->right&&root->val+sum==target){
                path.push_back(root->val);
                res.push_back(path);
                path.pop_back();
        }
        path.push_back(root->val);
        dfs(root->left,sum+root->val);
        dfs(root->right,sum+root->val);
        path.pop_back();
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        target=targetSum;
        dfs(root,0);
        return res;
    }
};
```

<h6 id="-7">[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)</h6>
给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。**路径**不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231408-4bffd62b-ebe9-4015-bc5b-b85afe6fa9e4.png)

每个节点都求路径个数，然后加起来。

遍历每个节点后都要考虑是不是符合target，如果符合target就把res++。

因为使用sum传参，所以不需要显示回溯。

```plain
class Solution {
public:
    int target; 
    int res;
    void rootSum(TreeNode* root, int sum) {
        if(!root)return;
        if((long long)root->val+sum==(long long)target)res++;
        rootSum(root->left, (long long)sum+root->val);
        rootSum(root->right, (long long)sum+root->val);
    }
    void dfs(TreeNode *root){
        if(!root) return;
        rootSum(root,0);
        dfs(root->left);
        dfs(root->right);
    }
    int pathSum(TreeNode* root, int targetSum) {
        if(!root)return 0;        
        target = targetSum;
        dfs(root);
        return res;
    }
};
```

<h6 id="-8">[2096. 从二叉树一个节点到另一个节点每一步的方向](https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/)</h6>
给你一棵 **二叉树** 的根节点 `root` ，这棵二叉树总共有 `n` 个节点。每个节点的值为 `1` 到 `n` 中的一个整数，且互不相同。给你一个整数 `startValue` ，表示起点节点 `s` 的值，和另一个不同的整数 `destValue` ，表示终点节点 `t` 的值。

请找到从节点 `s` 到节点 `t` 的 **最短路径** ，并以字符串的形式返回每一步的方向。每一步用 **大写** 字母 `'L'` ，`'R'` 和 `'U'` 分别表示一种方向：

+ `'L'` 表示从一个节点前往它的 **左孩子**节点。
+ `'R'` 表示从一个节点前往它的 **右孩子**节点。
+ `'U'` 表示从一个节点前往它的 **父** 节点。请你返回从 `s` 到 `t`**最短路径** 每一步的方向。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231940-d247a321-e4ec-4e66-8cd8-30acd6f860a6.png)

```plain
class Solution {
public:
    string path; string res;
    void dfs(TreeNode *root,int t,int dic){
        if(!root)return;
        if(root->val==t){
            //  if(dic==1)path+="L";
            //  else if(dic==2)path+="R";
            //  为什么不要上面两行.
            res = path;  return;
        }
  path+="L"；dfs(root->left,t,1);path.pop_back();
        path+="R";dfs(root->right,t,2);path.pop_back();
    }
    TreeNode* LCA(TreeNode *root,int s,int d ){
        if(!root)return nullptr;
        if(root->val==s||root->val==d)return root;
        TreeNode * l = LCA(root->left,s,d);TreeNode * r = LCA(root->right,s,d);
        if(!l)return r; if(!r)return l;
        return root;
    }
    string getDirections(TreeNode* root, int startValue, int destValue) {
        TreeNode *lca = LCA(root,startValue,destValue);
        string path1; string path2;  //cout<<lca->val<<endl;
        dfs(lca,startValue,0); 
        path1 = res; 
        res.clear();
        string path3;
        for(int i=0;i<path1.size();i++)path3+="U";
        dfs(lca,destValue,0);
        path2 = res; 
        res.clear();
        return path3+path2;
    }
};
```

<h6 id="-9">[1457. 二叉树中的伪回文路径](https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/)</h6>
给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「**伪回文**」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。请你返回从根到叶子节点的所有路径中 **伪回文 **路径的数目。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231894-9e19f25f-0d81-4d16-bf7e-7f300a910ac3.png)

伪回文：路径中1~9次数频率 奇数次数最多出现一次。类似上一题，在走完一条路径后，判断奇数次数是否最多出现一次。

```plain
class Solution {
public:
    int freq[10];
    bool judge(){
        int odd=0;
        for(int i=0;i<10;i++){
            if(freq[i]%2!=0)odd+=1;
        }
        return odd<=1;
    }
    int res=0;
    void dfs(TreeNode *root){
        if(!root)return;
        if(!root->left&&!root->right){
            freq[root->val]++;
            if(judge())res++;
            freq[root->val]--;
        }
        freq[root->val]++;
        dfs(root->left);dfs(root->right);
        freq[root->val]--;
    }
    int pseudoPalindromicPaths (TreeNode* root) {
        memset(freq,0,sizeof(freq));
        dfs(root);
        return res;
    }
};
```

<h6 id="-10">[二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)</h6>
(待整理)

题意：定义堂兄弟节点：层数相同，但是父节点不相同。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231969-3e88e6e1-7612-48c4-b244-9872ed9a5e08.png)

<!!!!>

bfs存数思路的错误，如果使用vector把每一层的节点值存下来(空值为-1)，然后判断位置如果相邻就是同一个父节点，这个思路反例如下。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810231981-8810b47e-9779-4425-964a-7ec4ac0c7cb3.png)

**思路：**dfs状态问题，类似走方格，每个方格的状态保存在参数中，如果遇到终点方格保存或者返回方格的状态。这个问题中的状态是节点的高度和父节点的值。

```plain
int hx,px;
void dfs(TreeNode *root,int x,int p,int h){
    if(!root)return;
    if(root->val==x){
        hx=h;p x=p;
        return;
    }
    dfs(root->left,x,root->val,h+1);
    dfs(root->right,x,root->val,h+1);
}
bool isCousins(TreeNode* root,int x,int y) {
        dfs(root,x,-1,0);
        int h1=hx;int p1=px;
        dfs(root,y,-1,0);
        int h2=hx;nt p2=px;
        if(h1==h2&&p1!=p2)return true;
        return false;
}
```

<h6 id="-11">[1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)</h6>
给你一棵根为 `root` 的二叉树，请你返回二叉树中好节点的数目。

「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232040-9cc63918-f302-4388-87f6-5eee739674a0.png)

DFS先序遍历，遍历的时候使用一个参数记录当前遍历的最大值，然后判断。

```plain
class Solution {
public: 
    int dfs(TreeNode *root,int cur_max){
        if(!root) return 0;
        int res = 0;
        if(root->val >= cur_max) res+=1;
        res+=dfs(root->left,max(cur_max,root->val))+dfs(root->right,max(cur_max,root->val));
        return res;
    }
    int goodNodes(TreeNode* root) {
        return dfs(root,INT_MIN);
    }
};
```

<h6 id="-12">[1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)</h6>
给定二叉树的根节点 `root`，找出存在于 **不同** 节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。(如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先)。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232440-0d032eae-0599-4879-91cf-20bca01bb3df.png)

dfs返回值尽量为void，使用全局变量传参，这样可以省很多代码。

```plain
class Solution {
public:
    int max_val = 0;
    int min_val = INT_MAX;
    void dfs(TreeNode *root){
        if(!root)return;
        max_val= max(root->val,max_val);
        min_val= min(root->val,min_val);
        dfs(root->left);
        dfs(root->right);
    }
    int ans = 0;
    void maxdfs(TreeNode *root){
        if(!root)return;
        max_val = 0; min_val  =INT_MAX;
        dfs(root);
        ans = max(ans,abs(root->val-max_val));
        ans = max(ans,abs(root->val-min_val));
        maxdfs(root->left);
        maxdfs(root->right);
    }
    int maxAncestorDiff(TreeNode* root) {
        maxdfs(root);
        return ans;
    }
};
```

<h6 id="-13">[1372. 二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)</h6>
给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

+ 选择二叉树中**任意**节点和一个方向(左或者右)。
+ 如果前进方向为右,那么移动到当前节点的的右子节点，否则移动到它的左子节点。
+ 改变前进方向:左变右或者右变左。重复第二步和第三步，直到你在树中无法继续移动。

交错路径的长度定义为:**访问过的节点数目-1(**单个节点的路径长度为 0 )。请你返回给定树中最长 **交错路径** 的长度。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232466-bac409c7-cb51-4d3b-8363-4714df6c3fb0.png)

下面有几个样例过不了（时间复杂度为O(n*n)）

```plain
class Solution {
public:
    int maxPath(TreeNode *root,int dic){
        if(!root)return 0;
        int len_left = maxPath(root->right,2);
        int len_right = maxPath(root->left,1);
        if(dic==1) return 1+len_left;
        else if(dic==2) return 1+len_right;
        else return 1+max(len_left,len_right);
    }

    int res=0;
    void dfs(TreeNode *root){
        if(!root) return;
        int len = maxPath(root,0);
        res=max(res,len);
        dfs(root->left); dfs(root->right);
    }
    int longestZigZag(TreeNode* root) {
        dfs(root);
        return res-1;
    }
};
```

后序遍历，在遍历的时候更新最长交错路径。这个写法第一次遇到，需要整理。

```plain
class Solution { 
public: 
    int res = 0; 
    // 后序遍历函数 
    pair<int, int> dfs(TreeNode* root) { 
        if (!root) return {0, 0};  
        // 递归处理左子树 
        auto [leftLeft, leftRight] = dfs(root->left); 
        // 递归处理右子树 
        auto [rightLeft, rightRight] = dfs(root->right); 
        // 当前节点的左之字形路径长度 
        int leftZigzag = 1 + leftRight; 
        // 当前节点的右之字形路径长度 
        int rightZigzag = 1 + rightLeft; 
        // 更新全局最长之字形路径长度 
        res = max({res, leftZigzag, rightZigzag});
        // 返回当前节点的左、右之字形路径长度 
        return {leftZigzag, rightZigzag}; 
    } 
    int longestZigZag(TreeNode* root) { 
        // 调用后序遍历函数 
        dfs(root); 
        // 返回最长之字形路径长度减1 
        return res - 1; 
    } 
};
```

<h6 id="-14">[971. 翻转二叉树以匹配先序遍历](https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/)</h6>
给你一棵二叉树的根节点 `root` ，树中有 `n` 个节点，每个节点都有一个不同于其他节点且处于 `1` 到 `n` 之间的值。另给你一个由`n`个值组成的行程序列`voyage`,表示**预期**的二叉树[先序遍历](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin)结果。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232490-7a76ff3f-8a56-4054-a434-91a91d5d7779.png)

为什么pos能正确指向应该比较的位置呢？比如，当遍历左子树时，每一步都会递增pos，处理完左子树之后，处理右子树的时候，pos是否已经正确指向右子树的起始位置？举个例子，假设当前节点是root，它的左右子树分别是left和right。那么先序遍历正常情况下是root，然后是left的所有节点，然后是right的所有节点。所以voyage数组中，root的位置是pos，然后是left的部分，之后是right的部分。这时候pos在递归处理root之后会递增到pos+1，处理left的时候，递归调用会处理整个左子树的节点，此时pos会递增到left子树结束的位置。然后处理右子树的时候，pos的位置正好是右子树的起始位置。这样整个过程是正确的。

共享下标的写法需要理解为什么是正确的。这题需要重新整理。

```plain
class Solution {
public:
    vector<int> ans;
    bool dfs (TreeNode* root, vector<int>& voyage, int& pos) {
        if (!root) return true;
        if (root->val != voyage[pos]) return false; 
        pos++;
        if (root->left && root->left->val!= voyage[pos]) { // 数组中左子树的区域不等于pos(root-val)+1的时候，我们需要在这里反转
            ans.push_back(root->val);
            return dfs(root->right, voyage, pos) && dfs(root->left, voyage, pos);
        } else {
            return dfs(root->left, voyage, pos) && dfs(root->right, voyage, pos);
        }
    }
    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
       // 模拟遍历，看看每次需不需要反转    
        int pos = 0; //在先序遍历中的位置，先序遍历数组中的分布为[root-Val, left tree part, right tree part]
        if (dfs(root, voyage, pos)) return ans;
        return {-1};
    }
};
```

<h5 id="10ddd29b"><font style="color:#0e52d4;">构建二叉树</font></h5>
<font style="color:#0e52d4;">（ 数组构建二叉树，</font>**<font style="color:#0e52d4;">有序数组构造平衡二叉树，</font>**<font style="color:#0e52d4;">二叉搜索树转平衡二叉树，，）</font>

<h6 id="f531a997">**数组构建二叉树**</h6>
没找到原题

```plain
build(nums,int l,int r):
       nums：i为根节点,左区间构造左子树,右区间构造右子树
       if(l>r)return null;
       TreeNode root=new nums[i]
       root.left=build(nums,l,i-1)
       root.right=build(nums,i+1,r)
       return root
```

<h6 id="d57bfdee">**二叉搜索树转平衡二叉树**</h6>
<!!!>中序转vector，然后使用vector中mid建树。

```plain
传入0,n-1
中序遍历然后对这个有序序列递归建树，
left= l,mid-1
right=mid+1,r
root=mid
```

<h6 id="9cde460f">**有序数组构造平衡二叉树**</h6>
[. - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

<!> mid构造根节点，递归构造左右子树.

```plain
build nums,l,r:
    if l>r return
        root=new nums[mid]//使用中间的数构造
        root.left=build(nums,l,mid-1)
        root.right=build(nums,mid+1,r)
        return root
```

<h6 id="2d405922">**由前序遍历和中序遍历构建二叉树**</h6>
[. - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

<!!>

前序遍历:根[左][右]

中序遍历:[左]根[右]

map存索引，中序找根，求左区间和右区间长度.

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232552-ed6feb14-e53d-4877-81b3-0c53b116fb27.png)

```plain
map[vin[i]] = i

//在中序遍历中迅速找到根节点,可以使用哈希表
build(pre,l1,r1,vin,l2,r2):
if r1>l1||r2>l2:return
root=new pre[l1];
int idx=map[pre[l1]]
int len=idx-1-l2+1;
root.left=build(pre,l1+1,l1+1+len-1,vin,l2,idx-1);
root.right=build(pre,l1+l+len-1+1,r1,vin,idx+1,r2);
```

<h6 id="b8dc9dfe">**LeetCode 654 最大二叉树**</h6>
[. - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/description/)

题意：给定一个不重复的整数数组 `nums` 。 

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

思路和使用vector构建二叉平衡树相同。

```plain
class Solution {
public:
    int findMax(vector<int>&nums,int l,int r){
        int midx=l;
        for(int i=l;i<=r;i++){
            if(nums[midx]<nums[i])midx=i;
        }
        return midx;
    }
    TreeNode *build(vector<int>&nums,int l,int r){
        if(l>r)return nullptr;//注意:不要忘写
        int idx=findMax(nums,l,r);
        TreeNode *root=new TreeNode(nums[idx]);
        root->left=build(nums,l,idx-1);
        root->right=build(nums,idx+1,r);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return build(nums,0,nums.size()-1);
    }
};
```

<h6 id="e77f6fcc">二叉树的序列化和反序列化（剑指offer）</h6>
二叉树的序列化

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232563-4b166c3d-3eb4-4907-a309-71f5a7612126.png)

方法：先序遍历这颗二叉树，遇到空子树的时候序列化成 `None`，否则继续递归序列化。

```plain
void rserialize(TreeNode *root,string &str){
  if(root==NULL)str+="None,";
  else{
      str+=to_string(root->val)+",";
      rserialize(root->left,str);
      rserialize(root->right,str);
    }
}
```

二叉树的反序列化

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232967-acfb3b67-2049-47e8-bc77-5ade24302e0e.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810232996-c15dbc16-2422-4040-a4e2-3b962f7cf1bd.png)

```plain
//根据链表建树
TreeNode* rdeserialize(list<string>& dataArray) {
        if (dataArray.front() == "None") {
            dataArray.erase(dataArray.begin());
            return nullptr;
        }//如果链表为空，则返回空树
        TreeNode* root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());//根节点
        root->left = rdeserialize(dataArray);//左子树
        root->right = rdeserialize(dataArray);//右子树
        return root;
}
//反序列化
    TreeNode* deserialize(string data) {
        list<string> dataArray;
        string str;
        //把二叉树节点序列化的值加入链表
        for (auto& ch : data) {
            if (ch == ',') {
                dataArray.push_back(str);
                str.clear();
            } else {
                str.push_back(ch);
            }
        }
        return rdeserialize(dataArray);
  }
```

<h5 id="383fcb99"><font style="color:#0e52d4;">二叉搜索树</font></h5>
<h6 id="5d3465ad">**判断二叉搜索树**</h6>
[. - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233126-51139efc-1c95-4ca1-a60d-ae7e001b09c0.png)

```plain
bool isValidBST(TreeNode* root, long long min_val = LONG_MIN, long long max_val = LONG_MAX){
 if (root == NULL) return true; // 空树是有效的 (易错1)
 if (root->val <= min_val || root->val >= max_val) return false; // 当前节点值超出范围
//递归检查左右子树
 return isValidBST(root->left, min_val, root->val) && isValidBST(root->right, root->val, max_val);
}
```

<h6 id="ab2ac06c">**修剪二叉搜索树**</h6>
[. - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/553805651/)

删除节点使BST所有节点都在[low, high]范围内:

思路类似判断二叉搜索树/_公共祖先：

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233101-e2d7e6f9-0505-487c-96fc-8fd23fc44565.png)

讨论根节点和[low,high]的关系，如果root小于low，直接返回修剪后的右子树，如果root大于high，直接返回修建后左子树，否则修建左右子树。

```plain
trim(root,low,high)：
      if root空||root叶子节点:讨论
      if root.val>high://删除右子树
           root=root.left
           return trim(root,low,high)
      else if root.val<low://删除左子树
           root=root.right
           return trim(root,low,high)
      else://对左子树和右子树修剪
           root.left=trim(root.left,low,high)
           root.right=trim(root.right,low,high)
           return root
```

<h6 id="1cc46c7f">**二叉搜索树的插入**</h6>
insert(root,val):root为空，新建一个节点。

如果小于root,insert(root->left,val)；右同理。

```plain
insert(root,val):
     root==null return new root(val)
     if root.val>val: root.left=insert(root.left,val);
     else root.right=insert(root.right,val);
     return root
```

<h6 id="ddfc200e">**二叉搜索树的搜索**</h6>
[. - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

三行类似先序遍历

```plain
search(root,val):
   if root==null: return null
   if root.val==val:return root;
   else root.val>val: search(root.left,val);
   else root.val<val: search(root.right,val);
```

<h6 id="7b4fa785">**二叉搜索树的删除**</h6>
[. - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/)

root!=val，不等于在左右子树中删除。

root==val。如果左右子树不全为空,返回另一颗子树(没有讨论)。如果全不为空,找右子树的最左叶子节点node。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233360-1634a81b-3072-4de7-9612-6a1fda84916f.png)

```plain
delete(root,val):
    if root=null return null;
    if root.val>val root.left=delete(root.left,val);
    else if
       root.val<val root.right=delete(root.right,val);
   else
       if root.left=null return root.right
       if root.right=null return root.left
//----------------------------------------------------
       TreeNode t=root.right;
       while(t.left!=null)t=t.left;
       t.left=root.left;
       root=root.right;
//----------------------------------------------------
   return root
```

<h6 id="-15">[814. 二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/)</h6>
思路和二叉搜索树中删除一个节点...... 相同。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233610-1af6c522-e183-48ce-aa01-ce711ae580d6.png)

[. - 力扣（LeetCode）](https://leetcode.cn/problems/pOCWxh/)

给定一个二叉树**根节点**`root`，树的每个节点的值要么是`0`，要么是`1`。

剪除该二叉树中所有节点的值为`0`的子树。节点`node`的子树为`node`本身，以及所有`node`的后代。

如果root 子树 全部为0，返回nullptr。

如果root 左子树全部为0，root->left为nullptr，否则修剪root->left。右子树操作类似。返回root。

```plain
bool judge(TreeNode *root){
        if(!root)return true;
        bool res=true;
        if(root->val==1)return false;
        return judge(root->left)&&judge(root->right);//注意这里的逻辑
 }
  /*判断以root为根的树是否全0。只有根节点不为0并且子树全不为0返回true*/
    TreeNode* pruneTree(TreeNode* root) {
        if(!root)return nullptr;
        if(judge(root))return nullptr;
        if(judge(root->left))root->left=nullptr;//左子树全0
        else root->left=pruneTree(root->left);
        if(judge(root->right))root->right=nullptr;//右子树全0  
        else root->right=pruneTree(root->right);
        return root;
    }
```

<h5 id="-16">[恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)</h5>
给你二叉搜索树的根节点`root`，该树中的 **恰好** 两个节点的值被错误地交换。_请在不改变其结构的情况下 恢复这棵树 _。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233641-1fd9d249-5793-482b-8918-42441ba72e95.png)

```plain
class Solution {
public:
    vector<TreeNode*> vec;
    void dfs(TreeNode* root) {
        if (!root)return;
        dfs(root->left);vec.push_back(root);dfs(root->right);
    }
    void recoverTree(TreeNode* root) {
        dfs(root); // 中序遍历收集节点
        TreeNode 
            *first = nullptr, 
            *second = nullptr, 
            *prev = nullptr;
        //查找两个异常节点
        for(auto node:vec){
            if (prev&&prev->val>node->val){
                if (!first) first = prev;//第一个异常点
                second=node;//最后一个异常点
            }
            prev = node;
        }
        // 交换两个异常节点的值
        if (first && second) {
            int temp = first->val;
            first->val = second->val;
            second->val = temp;
        }
    }
};
```

这个需要整理。

<h4 id="3bed5a5e">层序遍历相关</h4>
<h5 id="1f01882a">之字打印二叉树</h5>
层序遍历后按层反转vector

<h5 id="ba4d07c6">**判断完全二叉树**</h5>
没找到原题。

```plain
在所有叶子节点下补上两个null.
while:q
      t=q.poll
      if(t==null)continue;
      else
        q.add(t.left);
        q.add(t.right);
  完全二叉树:所有叶子节点补上Null之后。层序遍历中一定满足非空节点在左面，空节点在右面。
  如果非空节点中有一个空节点，那么不是完全二叉树。
```

<h5 id="8822d195">最大层内元素和</h5>
LeetCode1161

[https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/submissions/558741584/](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/submissions/558741584/)

返回一层中和最大的层号，如果有多个最大和，返回最小层数

<直接按层bfs遍历

```plain
int maxLevelSum(TreeNode* root) {
    queue<TreeNode*>q;
    q.push(root);
    int max_sum=INT_MIN;
    int sum;
    int min_level=0;
    int level=0;
    while(!q.empty()){
       int size=q.size();
       sum=0;
              level++;
              for(int i=0;i<size;i++){
              TreeNode * cur=q.front();
              q.pop();
              sum+=cur->val;
              if(cur->left)q.push(cur->left);
              if(cur->right)q.push(cur->right);
              }
              if(sum>max_sum){
                  max_sum=sum;
                  min_level=level;
              }
          }
          return min_level;
    }
```

<h5 id="254df0e6">找左下角的值</h5>
LeetCode513

[https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/)

层序遍历最后一层第一个值。

按层bfs遍历，用vector保存每层的节点，返回最后一层的第一个节点。

```plain
int findBottomLeftValue(TreeNode* root) {
      vector<int>level;
      queue<TreeNode*>que;
      if(root) que.push(root);
      while(!que.empty()){   
           int size=que.size();
           level.clear();
           for(int i=0;i<size;i++){
              TreeNode *cur=que.front();
              que.pop();
              level.push_back(cur->val);
              if(cur->left)que.push(cur->left);
              if(cur->right)que.push(cur->right); 
     return level[0];
```

<h5 id="59e9b098">二叉数的最大宽度</h5>
LeetCode 662

bfs按序遍历，保存节点的编号(unsigned long long)

给你一棵二叉树的根节点 root，返回树的 最大宽度。树的最大宽度是所有层中最大的宽度。

每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些null 节点也计入长度。

题目数据保证答案将会在32 位带符号整数范围内。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233641-31c742e0-1a36-49ac-9130-8629b39cb539.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233623-86894d68-3e11-4da8-8012-e3aaa397d47f.png)

上面思路错误，如果使用bfs保存空节点，那么最多只能保存一层空节点，空节点的空节点不能保存，因为访问不到。所以不能使用bfs，只能使用dfs。

换一种思路，同样使用bfs。

完全二叉树从1开始编号，在使用bfs层序遍历的时候，记录每个节点的序号和层数（因为按层bfs for循环中层数是确定的，所以可以不记录层数。）在添加左孩子时编号*2，添加右孩子时编号*2+1。

这样会出现一个问题，编号会太大(最坏情况时2^n)。

解决：no类型使用unsigned long long。

`unsigned long long` 至少支持 64 位整数。这意味着它可以存储从 0 到 264−1264−1 之间的值。  
所以大数都可以使用unsigned long long 来存储。

```plain
class Solution {
public:
    struct node{
        TreeNode *root;
       unsigned long long no;
    };
    int widthOfBinaryTree(TreeNode* root) {
        queue<node*>q;
        vector<node*>vec;
        node *t =new node(root,1);
        q.push(t);
        int level=1;
        unsigned long long res=0;
        while(!q.empty()){
            int size=q.size();
            vec.clear();
            for(int i=0;i<size;i++){
                node *t = q.front();
                q.pop();
                vec.push_back(t);
                if(t->root->left)
                     q.push(new node(t->root->left,(t->no)*2));
                if(t->root->right)
                     q.push(new node(t->root->right,(t->no)*2+1));
            }
            res=max(res,vec.back()->no-vec[0]->no+1);
            level++;
        }
        return res;
    }
};
```

<h4 id="15b75e18">中序遍历相关</h4>
二叉搜索树中序遍历是有序的。

<h5 id="f256e1d8">**二叉搜索树转循环链表**</h5>
```plain
vector<Node*> list; //创建一个列表来保存中序遍历的节点  
dfs(root, list); // 执行中序遍历，并将节点添加到列表中  
n = list.size(); // 获取列表中节点的数量  
if (n == 0) return nullptr; // 如果列表为空，则返回空指针  
    // 将列表中的节点连接成双向循环链表  
for (int i = 0; i < n; ++i) {  
   list[i]->left = list[(i - 1 + n) % n]; // 设置左指针为前一个节点  
   list[i]->right = list[(i + 1) % n];    // 设置右指针为后一个节点  
 }
return list[0]; // 返回链表的头节点（双向循环链表的任意节点都可以作为头节点）
```

<h5 id="b711ab3f">**二叉搜索树第k大节点**</h5>
[https://leetcode.cn/problems/kth-smallest-element-in-a-bst/](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

<!>转为vector暴搜

```plain
dfs(root):
   if(root==nullptr)return;
   dfs(root.right);
   cnt++;
   if(cnt==k){
      res=root.val;
      return;
   }
   dfs(root.left);
```

<h5 id="dba4519d">**二叉搜索树转换为累加数**</h5>
BST节点的权值变为大于等于节点权值之和

[https://leetcode.cn/problems/convert-bst-to-greater-tree/description/](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810233974-65db756f-41cb-45c1-acdd-229cd4e78e56.png)

节点的权值变为中序遍历的后缀和，即右中左序列的前缀和

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234042-7c93b3ca-9447-4919-b992-424e03ed42f5.png)

```plain
int sum = 0;//记录前一个节点的数值
void traversal(TreeNode* cur)://右中左遍历    
    if (cur == NULL)return;
    traversal(cur->right);
    cur->val += sum;
    sum = cur->val;
    traversal(cur->left);
(1)pre设为全局变量
(2)更新sum使用sum=cur->val
```

<h5 id="-17">[872. 叶子相似的树](https://leetcode.cn/problems/leaf-similar-trees/)</h5>
请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个**叶值序列。**

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234169-3b57ac79-85b4-4bc3-8a56-a468f226b185.png)

中序遍历后如果是叶子就加到res。如果res不相同，就false。

```plain
class Solution {
public:
    void dfs(TreeNode *root,vector<int>& res){
        if(!root)return;
        dfs(root->left,res);
        if(!root->left&&!root->right)res.push_back(root->val);
        dfs(root->right,res);
    }
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        vector<int>res1;
        vector<int>res2;
        dfs(root1,res1); dfs(root2,res2);
        if(res1.size()!=res2.size())return false;
        for(int i=0;i<res1.size();i++){
            if(res1[i]!=res2[i])return false;
        }
        return true;
    }
};
```

<h5 id="-18">[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)</h5>
给定一个二叉树的 **根节点**`root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<h4 id="f6a7967d">后序遍历相关</h4>
<h5 id="46902593">二叉树的直径</h5>
[https://leetcode.cn/problems/diameter-of-binary-tree/](https://leetcode.cn/problems/diameter-of-binary-tree/)

**（LeetCode 543）**

给你一棵二叉树的根节点,返回该树的直径。二叉树的直径是指树中任意两个节点之间最长路径的长度.这条路径可能经过也可能不经过根节点root。两节点之间路径的长度由它们之间边数表示。

<!!!> 递推式：根节点 res = max( h(node->left)+h(node->right),dfs(node->left),dfs(node->right));

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234156-e0d487fd-0717-4566-a904-70e3238c35f0.png)

```plain
int res=0;
int h(TreeNode*root){
    if(!root)return 0;
    return 1+max(h(root->left),h(root->right));
}
int length(TreeNode *root){
   return h(root->right)+h(root->left);
}

int diameterOfBinaryTree(TreeNode* root) {
        if(!root)return 0;
        res=max(res,length(root));
        diameterOfBinaryTree(root->left);
        diameterOfBinaryTree(root->right);
        return res;
}
```

另一种解法：

```plain
class Solution {
public:
    int ans; // 成员变量，用于存储最大直径
    int diameterOfBinaryTree(TreeNode* root) {
        // 初始化直径为0
        ans = 0;
        computeHeight(root);
        return ans;
    }
    int computeHeight(TreeNode* node) {
        if (node == nullptr) return -1;
        // 计算左右子树的高度
        int leftHeight = computeHeight(node->left) + 1;
        int rightHeight = computeHeight(node->right) + 1;
        // 更新最大直径
        ans = max(ans, leftHeight + rightHeight);
        // 返回当前节点为根的最大高度
        return max(leftHeight, rightHeight);
    }
};
```

<h5 id="-19">[687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)</h5>
![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234210-45d09a55-bd99-4e75-9f81-f470f6b4a36e.png)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234450-4a989a26-e2b6-4584-a09a-6a16bfa84c9b.png)

如果当前节点和左子树的值不同，左子树的链长可以视作 0，否则就是左子树的链长。

如果当前节点和右子树的值不同，右子树的链长可以视作 0，否则就是右子树的链长。

```plain
class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
        ans = 0; // 初始化全局答案为0
        if (root == nullptr) return ans;
        dfs(root);
        return ans;
    }
private:
    int ans;
    //将ans作为成员变量
    int dfs(TreeNode* node) {
        if(node == nullptr)return 0;
    //计算左右子树的最长同值路径长度
        int left_length = dfs(node->left);
        int right_length = dfs(node->right);
    //初始化当前节点的左右同值链长
        int current_left_chain = 0, current_right_chain = 0;
        // 如果左子节点存在且与当前节点值相同，则更新左边链长
        if (node->left && node->left->val == node->val) {
            current_left_chain = left_length + 1;
        }
        // 如果右子节点存在且与当前节点值相同，则更新右边链长
        if (node->right && node->right->val == node->val) {
            current_right_chain = right_length + 1;
        }
        // 更新全局答案：左右同值链的最大可能组合
        ans = max(ans, current_left_chain + current_right_chain);
        // 返回当前节点最长的同值链长度给父调用
        return max(current_left_chain, current_right_chain);
    }
};
```

<h5 id="-20">[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)</h5>
二叉树中的** 路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径** 至少包含一个 **节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root`，返回其**最大路径和** 。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234667-8fc0e6a3-90a8-45f1-82cf-dd2134947d50.png)

**链:**从下面的某个节点（不一定是叶子）到当前节点的路径。把这条链的节点值之和，作为 dfs 的返回值。如果节点值之和是负数，则返回 0。

**直径:**等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的某个节点（不一定是叶子）到 node 的链的节点值之和，去更新答案的最大值。

```plain
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        ans=INT_MIN; // 初始化最大路径和为最小整数值
        dfs(root); // 通过dfs计算最大路径和
        return ans; // 返回计算出的最大路径和
    }
private:
   int ans;//类的私有成员变量,用于存储最大路径和
   int dfs(TreeNode* node){
       if(node == nullptr) return 0; //空节点返回0
        //计算左右子树的最大链和,注意这里要与0比较取最大值，因为负数不如不选
       int leftMax = max(dfs(node->left), 0);
       int rightMax = max(dfs(node->right), 0);
        // 当前节点的最大路径和是当前节点值加上左右子树的最大链和
       int newPath = node->val + leftMax + rightMax;
        // 更新全局最大路径和
       ans = max(ans, newPath);
        // 返回经过当前节点的最大链和给父节点，注意只能选择左右子树的一边
       return node->val + max(leftMax, rightMax);
    }
}；
```

<h5 id="-21">[2385. 感染二叉树需要的总时间](https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/)</h5>
给你一棵二叉树的根节点 `root` ，二叉树中节点的值 **互不相同** 。另给你一个整数 `start` 。在第 `0` 分钟，**感染** 将会从值为 `start` 的节点开始爆发。每分钟如果节点满足以下全部条件就会被感染:节点此前还没有感染。节点与一个已感染节点相邻，返回感染整棵树需要的分钟数。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234738-773bd882-5f18-4845-a199-0fc7a5ed8ff7.png)

```plain
class Solution {
public:
    int amountOfTime(TreeNode* root, int start) {
        unordered_map<int, vector<int>> graph;//构建图
        buildGraph(root, nullptr, graph);//使用BFS计算感染整棵树所需的时间
        return calculateInfectionTime(graph, start);
    }
private:
    void buildGraph(TreeNode* node, TreeNode* parent, unordered_map<int, vector<int>>& graph) {
        if(node){
           //如果当前节点不是根节点，则连接父节点和子节点
           if(parent){
                graph[node->val].push_back(parent->val);
                graph[parent->val].push_back(node->val);
            }
            //连接左右子节点
            if(node->left){
                graph[node->val].push_back(node->left->val);
                graph[node->left->val].push_back(node->val);
            }
            if(node->right) {
                graph[node->val].push_back(node->right->val);
                graph[node->right->val].push_back(node->val);
            }
            // 递归构建左右子树的图
            buildGraph(node->left, node, graph);
            buildGraph(node->right, node, graph);
        }
    }
    int calculateInfectionTime(unordered_map<int, vector<int>>& graph, int start) {
        queue<vector<int>> q;
        q.push({start, 0});
        unordered_set<int> visited;
        visited.insert(start);
        int time = 0;
        while (!q.empty()) {
            auto arr = q.front();
            q.pop();
            int nodeVal = arr[0];
            time = arr[1];
            for (int childVal : graph[nodeVal]) {
                if (!visited.count(childVal)) {
                    q.push({childVal, time + 1});
                    visited.insert(childVal);
                }
            }
        }
        return time;
    }
};
```

<h5 id="b6dad670">**二叉（搜索）树的最近公共祖先**</h5>
[https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

<!!>

需要理解。left为空表示什么

p或q或root空返回null，p或q为root返回pq。

dfs求左右。

左空返回右右空返回左，否则返回root.

```plain
find(root,p,q)
         //p,q直接是root
         root=null||root=p||root=q return root;
         left=find(root.left,p,q)
         right=find(root.right,p,q)
         if left=null:return right //左子树找不到返回right
         if right=null:return left //右子树找不到返回left
         return root //p,q在root两侧返回root
```

<h5 id="c7ba4ced">**二叉树展开为链表**</h5>
//LeetCode 114

[https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

细节比较多，容易出错。展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。展开后的单链表应该与二叉树[先序遍历](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin)顺序相同。

把左子树展开成单链表，根节点指向左孩子节点，把右子树展开成单链表。左子树单链表的尾结点指向右子树的头结点（左子树不为空)。当左子树为空时，根节点直接指向右子树展开的单链表的头结点。

```plain
void flatten(TreeNode* root):
  if(root空或者root为叶子节点) return
  //展开左子树
  TreeNode *l=root->left;
  flatten(l);
  //展开右子树
  TreeNode *r=root->right;
  flatten(r);
  //释放根节点
  root->left=NULL;
  root->right=NULL;
  root->right=l;
  TreeNode *p=l;
  if p：
    while(p->right)p=p->right;
    p->right=r;
  else：
    root->right=r; 
  return;
```

需要额外保存左子树和右子树的位置，否则会丢失。需要判断左子树是否为空，如果为空，root->right直接指向右子树，否则指向左子树，然后左子树的最后一个节点指向右子树(使用之前保存到位置)

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234882-9d59c32a-d265-44c6-9b11-c177fd265cf7.png)

<h5 id="c5b0f4c2">**翻转二叉树**</h5>
[. - 力扣(LeetCode](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/))

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234883-1fbb2bf8-3d9b-48d3-9155-06edc2325b0b.png)

代码比较短，递归交换左右子树即可。

```plain
invertTree(root):  
   if root空或root为叶子节点 return root;
   l=invertTree(root->left);
   r=invertTree(root->right);
   root->right=l;
   root->left=r;
   return root;
```

<h5 id="-22">[3319. 第 K 大的完美二叉子树的大小](https://leetcode.cn/problems/k-th-largest-perfect-subtree-size-in-binary-tree/)</h5>
给你一棵 **二叉树 **的根节点 `root` 和一个整数`k`。返回第 `k` 大的 **完美二叉子树**的大小，如果不存在则返回 `-1`。**完美二叉树 **是指所有叶子节点都在同一层级的树，且每个父节点恰有两个子节点。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810234961-fb6575e6-3fa8-45ff-af0e-30fc6a324157.png)

后序遍历，如果左右子树高度相同，那么该树为完美二叉子树（满二叉树），直接把高度加到答案中。然后返回第k大的高度，2^(h-1)为高度为h的完美二叉树的节点个数。

根据完美二叉树的定义，一棵高为 h 的完美二叉树，从上往下，每一层恰好有 1,2,4,8,⋯,2^(h−1)个节点，所以子树大小为1+2+4+8+⋯+2^(h−1)=2^h−1。由于知道高度就知道了子树大小，DFS 只需返回子树高度。DFS的同时，用一个数组 hs 维护合法子树的高度。

定义二叉树的高度等于所有结点所在的不同层的数量，空二叉树的高度为 0，只有根结点的二叉树的高度为 1。完美二叉树的定义，高度为h的完美二叉树的大小是2^(h−1)，因此可以首先寻找二叉树中的所有完美二叉子树的高度，然后根据第 k 大的完美二叉子树的高度计算其大小。

由于一个二叉树的高度取决于其子树的高度，因此可以使用深度优先搜索计算每个子树的高度，同时判断每个子树是否为完美二叉子树，使用列表记录所有完美二叉子树的高度。为了实现判断完美二叉子树，规定不是完美二叉子树的子树的高度为 −1。

如果二叉树为空，则高度为 0；如果二叉树不为空,则分别计算左子树高度 leftHeight 和右子树高度 rightHeight。

1. 如果 leftHeight<0 或 rightHeight<0或者leftHeight!=rightHeight，则存在子树不是完美二叉子树或两个子树的高度不同，因此当前子树不是完美二叉子树，高度为−1。
2. 如果 leftHeight≥0且leftHeight=rightHeight，则当前子树不是完美二叉子树，高度为leftHeight+1，将当前子树的高度添加到所有完美二叉子树高度的列表中。

遍历结束之后，执行如下操作。

如果记录所有完美二叉子树的高度的列表中的元素个数小于 k，则不存在第 k 大的完美二叉子树，返回 −1。如果记录所有完美二叉子树的高度的列表中的元素个数大于等于 k，则将记录所有完美二叉子树的高度的列表按降序排序，排序后返回第 k 大的元素。

```plain
kthLargPBSub(root, k):
   clr glob list hts
   calcHts(root)
   if k > siz of hts:
      return -1
   sort hts 
   return (2 pow hts[siz(hts) - k]) - 1

calcHts(node):
   if node null:
        return 0
   lh=calcHts(node.left)
   rh=calcHts(node.right)
   if lh<0 or rh< 0 or lh != rh:
      return -1 // not perf subtr
   add (lh + 1) to glob list hts
   return lh + 1

class Solution {
public:
    vector<int>heights;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        heights.clear(); // 清空全局变量heights
        calculateHeights(root);
        if (k > heights.size()) {
            return -1;
        }
        sort(heights.begin(), heights.end());
        // 返回第k大的元素对应的完美二叉树的节点数量
        return (1 << heights[heights.size() - k]) - 1;
    }
private:
    int calculateHeights(TreeNode* node) {
        if (node == nullptr) return 0;
        int leftHeight = calculateHeights(node->left);
        int rightHeight = calculateHeights(node->right);
        if(leftHeight < 0 ||right<0 ||leftHeight != rightHeight) return -1; // 不合法
        // 记录当前节点代表的完美二叉树的高度
        heights.push_back(leftHeight + 1);
        return leftHeight + 1;
    }
};
```

<h5 id="-23">[1145. 二叉树着色游戏](https://leetcode.cn/problems/binary-tree-coloring-game/)</h5>
以后整理

<h5 id="-24">[1325. 删除给定值的叶子节点](https://leetcode.cn/problems/delete-leaves-with-a-given-value/)</h5>
给你一棵以 `root` 为根的二叉树和一个整数 `target` ，请你删除所有值为 `target` 的 **叶子节点** 。

注意，一旦删除值为 `target` 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 `target` ，那么这个节点也应该被删除。重复此过程直到不能继续删除。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810235416-8fde3ba7-2f2a-4cf9-9a97-f91aa915388f.png)

由于我们需要删除所有值为 target 的叶子节点，那么我们的操作顺序应当从二叉树的叶子节点开始，逐步向上直到二叉树的根为止。因此我们可以使用递归的方法遍历整颗二叉树，并在回溯时进行删除操作。这样对于二叉树中的每个节点，它的子节点一定先于它被操作。二叉树的后序遍历。

```plain
class Solution{
public:
    TreeNode* removeLeafNodes(TreeNode* root, int target){
        if(!root)return nullptr;
        root->left  = removeLeafNodes(root->left,target);
        root->right = removeLeafNodes(root->right,target);
        if (!root->left&&!root->right&&root->val==target)return nullptr;
        return root;
    }
};
```

<h5 id="-25">[1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/)</h5>
给出二叉树的根节点`root`，树上每个节点都有一个不同的值。如果节点值在`to_delete`中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合)。返回森林中的每棵树。你可以按任意顺序组织答案。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810235451-f92d006f-31d9-43bc-814d-dbb96cfaaacd.png)

toDelete 全部丢到一个哈希表 s 中，这样可以O(1)判断节点值是否在 toDelete 中。

如果当前节点被删除，但是左儿子(右儿子)没被删除，左儿子(右儿子)是一棵树的根节点加入答案。

```plain
class Solution {
    vector<TreeNode*> ans;
    unordered_set<int> s;
    TreeNode* dfs(TreeNode *root) {
        if(root == nullptr)return nullptr;
        root->left=dfs(root->left);
        root->right=dfs(root->right);
        if (!s.count(root->val)) return root;
        //  如果root的值在删除，非空的左右子树需要加到ans中
        //  (只需要加一个节点即可)
        if (root->left) ans.push_back(root->left);
        if (root->right) ans.push_back(root->right);
        return nullptr;
    }
public:
    vector<TreeNode*> delNodes(TreeNode *root, vector<int> &to_delete) {
        for (int x : to_delete) s.insert(x);
        if (dfs(root)) ans.push_back(root);
        return ans;
    }
};
```

<h5 id="-26">[865. 具有所有最深节点的最小子树](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/)</h5>
给定一个根为 `root` 的二叉树，每个节点的深度是 **该节点到根的最短距离** 。返回包含原始树中所有 **最深节点** 的 _最小子树_ 。如果一个节点在 **整个树 **的任意节点之间具有最大的深度，则该节点是 **最深的** 。一个节点的**子树**是该节点加上它的所有后代的集合。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810235741-ab5b67b0-efc6-4ef7-bb86-96770d3d762e.png)

把每棵子树都看成是一个「子问题」，即对于每棵子树，我们需要知道：

这棵子树最深叶结点的深度。这里是指叶子在这棵子树内的深度，而不是在整棵二叉树的视角下的深度。相当于这棵子树的高度。这棵子树的最深叶结点的最近公共祖先 lca。

**分类讨论：**

设子树的根节点为 node，node 的左子树的高度为 leftHeight，node 的右子树的高度为 rightHeight。

如果leftHeight>rightHeight，那么子树的高度为 leftHeight+1，lca 是左子树的 lca。如果leftHeight<rightHeight，那么子树的高度为 rightHeight+1，lca 是右子树的 lca。如果leftHeight=rightHeight，那么子树的高度为 leftHeight+1，lca 就是 node。

反证法：如果 lca 在左子树中，那么 lca 不是右子树的最深叶结点的祖先，这不对；如果 lca 在右子树中，那么 lca 不是左子树的最深叶结点的祖先，这也不对；如果 lca 在 node 的上面，那就不符合「最近」的要求。所以 lca 只能是 node。

```plain
class Solution {
    pair<int, TreeNode*> dfs(TreeNode *node) {
        if (node == nullptr)
            return {0, nullptr};
        auto [left_height, left_lca] = dfs(node->left);
        auto [right_height, right_lca] = dfs(node->right);
        if (left_height > right_height) // 左子树更高
            return {left_height + 1, left_lca};
        if (left_height < right_height) // 右子树更高
            return {right_height + 1, right_lca};
        return {left_height + 1, node}; // 一样高
    }
public:
    TreeNode *subtreeWithAllDeepest(TreeNode *root) {
        return dfs(root).second;
    }
};
```

（思路类似最近公共祖先）

<h5 id="-27">[1080. 根到叶路径上的不足节点](https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/)</h5>
给你二叉树的根节点 `root` 和一个整数 `limit` ，请你同时删除树中所有 **不足节点 **，并返回最终二叉树的根节点。假如从根节点通过节点 `node` 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 `limit`，则该节点被称之为** 不足节点 **，需要被删除。

![](https://cdn.nlark.com/yuque/0/2025/png/45533403/1742810235499-5474e41e-bb17-401c-934d-53b837d8debd.png)

(递归) O(n)

采用自底向上的删除策略。如果某个结点是叶子结点，则判断到根结点的路径是否小于 limit。如果小于，则直接将其变为 NULL。如果不是叶子结点，则递归删除左儿子结点和（或）右儿子结点。如果当前结点变为了叶子结点，也将其变为 NULL，因为这代表着所有 “根-叶” 路径都小于 limit。

```plain
class Solution {
public:
    void cut(TreeNode* &root, int limit, int sum) {
        if(!root->left&&!root->right){
            if(sum<limit) root=NULL; // 叶子节点
            return;
        }
        if (root->left) cut(root -> left,limit,sum+root->left-> val);
        if (root -> right) cut(root -> right, limit, sum + root -> right -> val);;;
        if (!root->left&&!root-> right) root = NULL;
        // 如果左右子树都不是合法路径被删了，那么root就要被删掉.
    }
    TreeNode* sufficientSubset(TreeNode* root, int limit) {
        cut(root,limit,root->val);
        return root;
    }
};
```

```plain
class Solution {
public:
    int ans; // 成员变量，用于存储最大直径
    int diameterOfBinaryTree(TreeNode* root) {
        // 初始化直径为0
        ans = 0;
        computeHeight(root);
        return ans;
    }
    int computeHeight(TreeNode* node) {
        if (node == nullptr) return -1;
        // 计算左右子树的高度
        int leftHeight = computeHeight(node->left) + 1;
        int rightHeight = computeHeight(node->right) + 1;
        // 更新最大直径
        ans = max(ans, leftHeight + rightHeight);
        // 返回当前节点为根的最大高度
        return max(leftHeight, rightHeight);
    }
};
```

